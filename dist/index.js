var a=class extends Error{constructor(t,s,n,r){super(`HTTP Error ${t}: ${s}`);this.status=t;this.statusText=s;this.data=n;this.config=r;this.name="HttpError"}};var d=class{constructor(e={}){this.requestInterceptors=[];this.responseInterceptors=[];var t,s,n,r;this.baseURL=(t=e.baseURL)!=null?t:"",this.defaultHeaders={"Content-Type":"application/json",...e.headers},this.timeout=(s=e.timeout)!=null?s:3e4,this.retries=(n=e.retries)!=null?n:0,this.retryDelay=(r=e.retryDelay)!=null?r:1e3}addRequestInterceptor(e){return this.requestInterceptors.push(e),()=>{let t=this.requestInterceptors.indexOf(e);t!==-1&&this.requestInterceptors.splice(t,1)}}addResponseInterceptor(e){return this.responseInterceptors.push(e),()=>{let t=this.responseInterceptors.indexOf(e);t!==-1&&this.responseInterceptors.splice(t,1)}}async get(e,t){return this.request("GET",e,void 0,t)}async post(e,t,s){return this.request("POST",e,t,s)}async put(e,t,s){return this.request("PUT",e,t,s)}async delete(e,t){return this.request("DELETE",e,void 0,t)}async patch(e,t,s){return this.request("PATCH",e,t,s)}async request(e,t,s,n={}){var p,i,R,h;let r={...n,method:e,url:this.buildUrl(t,n.params),headers:{...this.defaultHeaders,...n.headers},data:s,retries:(p=n.retries)!=null?p:this.retries,retryDelay:(i=n.retryDelay)!=null?i:this.retryDelay};try{r=await this.applyRequestInterceptors(r),r.transformRequest&&r.data&&(r.data=await r.transformRequest(r.data));let u=new AbortController,l=setTimeout(()=>u.abort(),(R=r.timeout)!=null?R:this.timeout),m=(h=r.signal)!=null?h:u.signal,o=await fetch(r.url,{method:r.method,headers:r.headers,body:r.data?JSON.stringify(r.data):void 0,signal:m});clearTimeout(l),o=await this.applyResponseInterceptors(o);let c=await this.parseResponse(o);if(!o.ok)throw new a(o.status,o.statusText,c,r);return r.transformResponse?r.transformResponse(c,o.headers):c}catch(u){if(r.retries>0&&this.shouldRetry(u))return await this.delay(r.retryDelay),this.request(e,t,s,{...r,retries:r.retries-1});throw u}}async applyRequestInterceptors(e){let t={...e};for(let s of this.requestInterceptors)try{t=await s.onRequest(t)}catch(n){throw s.onRequestError&&await s.onRequestError(n),n}return t}async applyResponseInterceptors(e){let t=e;for(let s of this.responseInterceptors)try{t=await s.onResponse(t)}catch(n){throw s.onResponseError&&await s.onResponseError(n),n}return t}async parseResponse(e){let t=e.headers.get("content-type");return t!=null&&t.includes("application/json")?e.json():t!=null&&t.includes("text/")?e.text():e.blob()}buildUrl(e,t){let s=e.startsWith("http")?e:`${this.baseURL}${e.startsWith("/")?e:`/${e}`}`;if(!t)return s;let n=new URLSearchParams;Object.entries(t).forEach(([p,i])=>{i!=null&&n.append(p,i)});let r=n.toString();return r?`${s}${s.includes("?")?"&":"?"}${r}`:s}shouldRetry(e){return e instanceof a?e.status>=500||e.status===0:!0}delay(e){return new Promise(t=>setTimeout(t,e))}};export{d as HttpClient,a as HttpError};
//# sourceMappingURL=index.js.map