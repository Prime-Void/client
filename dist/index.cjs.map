{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/client.ts"],"sourcesContent":["export { HttpClient } from './client';\nexport { HttpError, type ClientConfig, type RequestConfig, type HttpMethod } from './types';\n","export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n\nexport interface RequestConfig {\n  method?: HttpMethod;\n  url?: string;\n  headers?: Record<string, string>;\n  params?: Record<string, string>;\n  timeout?: number;\n  signal?: AbortSignal;\n  retries?: number;\n  retryDelay?: number;\n  transformRequest?: RequestTransformer;\n  transformResponse?: ResponseTransformer;\n  data?: unknown;\n}\n\nexport interface ClientConfig {\n  baseURL?: string;\n  headers?: Record<string, string>;\n  timeout?: number;\n  retries?: number;\n  retryDelay?: number;\n}\n\nexport interface RequestInterceptor {\n  onRequest: (config: RequestConfig) => Promise<RequestConfig> | RequestConfig;\n  onRequestError?: (error: unknown) => Promise<unknown>;\n}\n\nexport interface ResponseInterceptor {\n  onResponse: (response: Response) => Promise<Response> | Response;\n  onResponseError?: (error: unknown) => Promise<unknown>;\n}\n\nexport type RequestTransformer = (data: unknown) => unknown | Promise<unknown>;\nexport type ResponseTransformer = (data: unknown, headers: Headers) => unknown | Promise<unknown>;\n\nexport class HttpError extends Error {\n  constructor(\n    public readonly status: number,\n    public readonly statusText: string,\n    public readonly data?: any,\n    public readonly config?: RequestConfig\n  ) {\n    super(`HTTP Error ${status}: ${statusText}`);\n    this.name = 'HttpError';\n  }\n}\n\nexport interface RetryConfig {\n  retries: number;\n  retryDelay: number;\n  shouldRetry?: (error: unknown) => boolean;\n}\n","import { ClientConfig, HttpError, HttpMethod, RequestConfig, RequestInterceptor, ResponseInterceptor } from './types';\n\n/**\n * A lightweight and modern HTTP client for making API requests\n */\nexport class HttpClient {\n  private baseURL: string;\n  private defaultHeaders: Record<string, string>;\n  private timeout: number;\n  private retries: number;\n  private retryDelay: number;\n  private requestInterceptors: RequestInterceptor[] = [];\n  private responseInterceptors: ResponseInterceptor[] = [];\n\n  constructor(config: ClientConfig = {}) {\n    this.baseURL = config.baseURL ?? '';\n    this.defaultHeaders = {\n      'Content-Type': 'application/json',\n      ...config.headers,\n    };\n    this.timeout = config.timeout ?? 30000;\n    this.retries = config.retries ?? 0;\n    this.retryDelay = config.retryDelay ?? 1000;\n  }\n\n  /**\n   * Add a request interceptor\n   */\n  addRequestInterceptor(interceptor: RequestInterceptor): () => void {\n    this.requestInterceptors.push(interceptor);\n    return () => {\n      const index = this.requestInterceptors.indexOf(interceptor);\n      if (index !== -1) {\n        this.requestInterceptors.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Add a response interceptor\n   */\n  addResponseInterceptor(interceptor: ResponseInterceptor): () => void {\n    this.responseInterceptors.push(interceptor);\n    return () => {\n      const index = this.responseInterceptors.indexOf(interceptor);\n      if (index !== -1) {\n        this.responseInterceptors.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Sends a GET request to the specified URL\n   */\n  async get<T>(url: string, config?: RequestConfig): Promise<T> {\n    return this.request<T>('GET', url, undefined, config);\n  }\n\n  /**\n   * Sends a POST request to the specified URL with data\n   */\n  async post<T>(url: string, data?: unknown, config?: RequestConfig): Promise<T> {\n    return this.request<T>('POST', url, data, config);\n  }\n\n  /**\n   * Sends a PUT request to the specified URL with data\n   */\n  async put<T>(url: string, data?: unknown, config?: RequestConfig): Promise<T> {\n    return this.request<T>('PUT', url, data, config);\n  }\n\n  /**\n   * Sends a DELETE request to the specified URL\n   */\n  async delete<T>(url: string, config?: RequestConfig): Promise<T> {\n    return this.request<T>('DELETE', url, undefined, config);\n  }\n\n  /**\n   * Sends a PATCH request to the specified URL with data\n   */\n  async patch<T>(url: string, data?: unknown, config?: RequestConfig): Promise<T> {\n    return this.request<T>('PATCH', url, data, config);\n  }\n\n  /**\n   * Core method to make HTTP requests\n   */\n  private async request<T>(\n    method: HttpMethod,\n    url: string,\n    data?: unknown,\n    config: RequestConfig = {}\n  ): Promise<T> {\n    let currentConfig: RequestConfig = {\n      ...config,\n      method,\n      url: this.buildUrl(url, config.params),\n      headers: { ...this.defaultHeaders, ...config.headers },\n      data,\n      retries: config.retries ?? this.retries,\n      retryDelay: config.retryDelay ?? this.retryDelay,\n    };\n\n    try {\n      // Apply request interceptors\n      currentConfig = await this.applyRequestInterceptors(currentConfig);\n\n      // Transform request data if needed\n      if (currentConfig.transformRequest && currentConfig.data) {\n        currentConfig.data = await currentConfig.transformRequest(currentConfig.data);\n      }\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), currentConfig.timeout ?? this.timeout);\n      const signal = currentConfig.signal ?? controller.signal;\n\n      let response = await fetch(currentConfig.url!, {\n        method: currentConfig.method!,\n        headers: currentConfig.headers,\n        body: currentConfig.data ? JSON.stringify(currentConfig.data) : undefined,\n        signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      // Apply response interceptors\n      response = await this.applyResponseInterceptors(response);\n\n      const responseData = await this.parseResponse(response);\n\n      if (!response.ok) {\n        throw new HttpError(response.status, response.statusText, responseData, currentConfig);\n      }\n\n      // Transform response data if needed\n      if (currentConfig.transformResponse) {\n        return currentConfig.transformResponse(responseData, response.headers) as T;\n      }\n\n      return responseData as T;\n    } catch (error) {\n      if (currentConfig.retries! > 0 && this.shouldRetry(error)) {\n        await this.delay(currentConfig.retryDelay!);\n        return this.request<T>(method, url, data, {\n          ...currentConfig,\n          retries: currentConfig.retries! - 1,\n        });\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Apply request interceptors in sequence\n   */\n  private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {\n    let currentConfig = { ...config };\n    for (const interceptor of this.requestInterceptors) {\n      try {\n        currentConfig = await interceptor.onRequest(currentConfig);\n      } catch (error) {\n        if (interceptor.onRequestError) {\n          await interceptor.onRequestError(error);\n        }\n        throw error;\n      }\n    }\n    return currentConfig;\n  }\n\n  /**\n   * Apply response interceptors in sequence\n   */\n  private async applyResponseInterceptors(response: Response): Promise<Response> {\n    let currentResponse = response;\n    for (const interceptor of this.responseInterceptors) {\n      try {\n        currentResponse = await interceptor.onResponse(currentResponse);\n      } catch (error) {\n        if (interceptor.onResponseError) {\n          await interceptor.onResponseError(error);\n        }\n        throw error;\n      }\n    }\n    return currentResponse;\n  }\n\n  /**\n   * Parse response based on content type\n   */\n  private async parseResponse(response: Response): Promise<any> {\n    const contentType = response.headers.get('content-type');\n    if (contentType?.includes('application/json')) {\n      return response.json();\n    }\n    if (contentType?.includes('text/')) {\n      return response.text();\n    }\n    return response.blob();\n  }\n\n  /**\n   * Builds the final URL with query parameters\n   */\n  private buildUrl(url: string, params?: Record<string, string>): string {\n    const finalUrl = url.startsWith('http') ? url : `${this.baseURL}${url.startsWith('/') ? url : `/${url}`}`;\n    \n    if (!params) {\n      return finalUrl;\n    }\n\n    const searchParams = new URLSearchParams();\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        searchParams.append(key, value);\n      }\n    });\n\n    const queryString = searchParams.toString();\n    return queryString ? `${finalUrl}${finalUrl.includes('?') ? '&' : '?'}${queryString}` : finalUrl;\n  }\n\n  /**\n   * Determine if a request should be retried\n   */\n  private shouldRetry(error: unknown): boolean {\n    if (error instanceof HttpError) {\n      // Retry on network errors and 5xx server errors\n      return error.status >= 500 || error.status === 0;\n    }\n    return true;\n  }\n\n  /**\n   * Delay helper for retry mechanism\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","HttpClient","HttpError","__toCommonJS","HttpError","status","statusText","data","config","HttpClient","config","_a","_b","_c","_d","interceptor","index","url","data","method","currentConfig","controller","timeoutId","signal","response","responseData","HttpError","error","currentResponse","contentType","params","finalUrl","searchParams","key","value","queryString","ms","resolve"]}